DAY 4 

1)BALANCED BINARY TREE 

//SOLUTION IN JAVA 

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int height(TreeNode root){
        if(root==null){
            return 0;
        }
        int l=height(root.left);
        int r=height(root.right);
        return Math.max(l,r)+1;
    }
    public boolean isBalanced(TreeNode root) {
        if(root==null){
            return true;
        }
        boolean lc=isBalanced(root.left);
        if(lc==false){
            return false;
        }
        boolean rc=isBalanced(root.right);
        if(rc==false){
            return false;
        }
        int lh=height(root.left);
        int rh=height(root.right);
        if(Math.abs(lh-rh)>1){
            return false;
        }
        return true;
    }
}

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------

2)DIAMETER OF A BINARY TREE 

//METHOD 1: SOLUTION IN JAVA 

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int height(TreeNode root){
        if(root==null){
            return 0;
        }
        int l=height(root.left);
        int r=height(root.right);
        return Math.max(l,r)+1;
    }
    int dia;
    public int diameterOfBinaryTree(TreeNode root) {
        if(root==null){
            return 0;
        }
        int lh=height(root.left);
        int rh=height(root.right);
        if(lh+rh>dia){
            dia=lh+rh;
        }
        diameterOfBinaryTree(root.left);
        diameterOfBinaryTree(root.right);
        return dia;
    }
}

//METHOD 2:SOLUTION IN JAVA 

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int dia;
    public int height(TreeNode root){
        if(root==null){
            return 0;
        }
        int l=height(root.left);
        int r=height(root.right);
        if(l+r>dia){
            dia=l+r;
        }
        return Math.max(l,r)+1;
    }
    public int diameterOfBinaryTree(TreeNode root) {
        height(root);
        return dia;
    }
}

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

3)BINARY TREE MAXIMUM PATH SUM 

//SOLUTION IN JAVA 

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int maxsum=Integer.MIN_VALUE;
    public int pathsum(TreeNode root){
        if(root==null){
            return 0;
        }
        int l=Math.max(0,pathsum(root.left));
        int r=Math.max(0,pathsum(root.right));
        int currsum=l+r+root.val;
        if(currsum>maxsum){
            maxsum=currsum;
        }
        return Math.max(l,r)+root.val;
    }
    public int maxPathSum(TreeNode root) {
        if(root.left==null && root.right==null){
            return root.val;
        }
        pathsum(root);
        return maxsum;
    }
}

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------

4)REMOVE DUPLICATES FROM SORTED LIST 

//SOLUTION IN JAVA 

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        ListNode curr=head;
        if(head==null){
            return head;
        }
        ListNode temp=head.next;
        ListNode prev=head;
        while(temp!=null){
            if(temp.val==prev.val){
                temp=temp.next;
                prev.next=temp;
            }
            else{
                prev=prev.next;
                temp=temp.next;
            }
        }
        return curr;
    }
}

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------

5)REMOVE DUPLICATES FROM SORTED LIST ||


//SOLUTION IN JAVA 


/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        ListNode res=new ListNode(-1,head);
        ListNode prev=res;
        if(head==null){
            return head;
        }
        while(head!=null){
            if(head.next!=null && head.val==head.next.val){
                while(head.next!=null && head.val==head.next.val){
                    head=head.next;
                }
                prev.next=head.next;
            }
            else{
                prev=prev.next;
            }
            head=head.next;
        }
        return res.next;
    }
}

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

6)MERGE SORTED ARRAY 

//SOLUTION IN JAVA 

class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int i=m-1;
        int j=n-1;
        int k=m+n-1;
        while(j>=0)
        {
            if(i>=0 && nums1[i]>nums2[j])
            {
                nums1[k]=nums1[i];
                k--;
                i--;
            }
            else{
                nums1[k]=nums2[j];
                k--; 
                j--;
            }
        }
    }
}

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

7)CLIMBING STAIRS 

//SOLUTION IN JAVA 

class Solution {
    public int climbStairs(int n) {
        if(n==0 || n==1){
            return 1;
        }
        if(n==2){
            return 2;
        }
        int[] res=new int[n];
        res[0]=1;
        res[1]=2;
        for(int i=2;i<n;i++){
            res[i]=res[i-1]+res[i-2];
        }
        return res[n-1];
    }
}

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

8)CONVERT SORTED ARRAY TO BINARY SEARCH TREE 

//SOLUTION IN JAVA 

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode tree(int[] nums,int i,int j)
    {
        if(i>j){
            return null;
        }
        int mid=(i+j)/2;
        TreeNode main=new TreeNode(nums[mid]);
        main.left=tree(nums,i,mid-1);
        main.right=tree(nums,mid+1,j);
        return main;
    }
    public TreeNode sortedArrayToBST(int[] nums) {
        return tree(nums,0,nums.length-1);
    }
}

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

9)VALID PALINDROME

//SOLUTION IN PYTHON 

class Solution:
    def isPalindrome(self, s: str) -> bool:
        ns=''
        for i in s.lower():
            if(i.isalpha() or i.isdigit()):
                ns+=i
        if(ns==ns[::-1]):
            return True
        else:
            return False


---------------------------------------------------------------------------------------------------------------------------------------------------------------------------

10)BEST TIME TO BUY AND SELL STOCK 

//SOLUTION IN JAVA 

class Solution {
    public int maxProfit(int[] prices) {
        int l=0;
        int r=1;
        int p=0;
        while(r<prices.length){
            if(prices[l]<prices[r]){
                p=Math.max(p,prices[r]-prices[l]);
            }
            else{
                l=r;
            }
            r++;
        }
        return p;
    }
}

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

11)PASCALS'S TRIANGLE 

//SOLUTION IN JAVA 

class Solution {
    public List<List<Integer>> generate(int numRows) {
        if(numRows == 0){
            return new ArrayList();
        }
        List<List<Integer>> tri = new ArrayList();
        for(int i=1; i<=numRows; i++)
        {
            List<Integer> row = new ArrayList();
            for(int j=0;j<i;j++)
            {
                if(j==0 || j==i-1)
                {
                    row.add(1);
                }
                else
                {
                    row.add(tri.get(i-2).get(j) + tri.get(i-2).get(j-1));
                }       
            }
            tri.add(row);
        }
        return tri;
    }
}

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

12)PASCAL'S TRIANGLE || 

//SOLUTION IN JAVA 

class Solution {
    public List<Integer> getRow(int rowIndex) {
        List<List<Integer>> res=generate(rowIndex+1);
        return res.get(rowIndex);
    }
    public List<List<Integer>> generate(int numRows) {
        if(numRows == 0){
            return new ArrayList();
        }
        List<List<Integer>> tri = new ArrayList();
        for(int i=1; i<=numRows; i++)
        {
            List<Integer> row = new ArrayList();
            for(int j=0;j<i;j++)
            {
                if(j==0 || j==i-1)
                {
                    row.add(1);
                }
                else
                {
                    row.add(tri.get(i-2).get(j) + tri.get(i-2).get(j-1));
                }       
            }
            tri.add(row);
        }
        return tri;
    }
}

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

13)ISOMORPHIC STRINGS 

//SOLUTION IN PYTHON

class Solution:
    def isIsomorphic(self, s: str, t: str) -> bool:
        if(len(s)!=len(t)):
            return False
        dic={}
        for i in range(len(s)):
            if s[i] not in dic.keys() and t[i] not in dic.values():
                dic[s[i]]=t[i]
        res=True
        for i in range(len(t)):
            if(s[i] not in dic.keys()):
                return False
            if t[i]==dic[s[i]]:
                res=True
            else:
                res=False
                break
        return res
        
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


14)UGLY NUMBER 

//SOLUTION IN JAVA 

class Solution {
    public boolean isUgly(int n) {
        if(n==0) {
            return false;
        }
        while(n%2==0){
            n=n/2;
        }
        while(n%3==0){
            n=n/3;
        }
        while(n%5==0){
            n=n/5;
        }
        if(n==1) return true;
        return false;
    }
}

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------



