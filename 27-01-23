DAY 5

1)BINARY TREE LEVEL ORDER TRAVERSAL 

//SOLUTION IN JAVA 

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>>ans=new LinkedList<>();
        if(root==null){
            return ans;
        }
        Queue<TreeNode>n=new LinkedList<>();
        n.add(root);
        while(!n.isEmpty()){
            List<Integer>l=new ArrayList<>();
            int count=n.size();
            for(int i=0;i<count;i++){
                TreeNode cur=n.poll();
                l.add(cur.val);
                if(cur.left!=null){
                    n.add(cur.left);
                }
                if(cur.right!=null){
                    n.add(cur.right);
                }
                
            }
            ans.add(l);
        }
        return ans;
    }
}

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


2)BINARY TREE RIGHT SIDE VIEW 

//SOLUTION IN JAVA 

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> l=new ArrayList<>();
        if(root==null){
            return l;
        }
        Queue<TreeNode>n=new LinkedList<>();
        n.add(root);
        while(!n.isEmpty()){
            int count=n.size();
            for(int i=0;i<count;i++){
                TreeNode cur=n.poll();
                if(i==count-1){
                    l.add(cur.val);
                }
                if(cur.left!=null){
                    n.add(cur.left);
                }
                if(cur.right!=null){
                    n.add(cur.right);
                }
            }
        }
        return l;       
    }
}

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


3)BINARY TREE ZIGZAG LEVEL ORDER TRAVERSAL 

//SOLUTION IN JAVA 

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>>ans=new LinkedList<>();
        if(root==null){
            return ans;
        }
        Queue<TreeNode>n=new LinkedList<>();
        n.add(root);
        Boolean forw=true;
        while(!n.isEmpty()){
            List<Integer>l=new ArrayList<>();
            int count=n.size();
            for(int i=0;i<count;i++){
                TreeNode cur=n.poll();
                if(forw){
                    l.add(cur.val);
                }
                else{
                    l.add(0,cur.val);
                }
                if(cur.left!=null){
                    n.add(cur.left);
                }
                if(cur.right!=null){
                    n.add(cur.right);
                }   
            }
            ans.add(l);
            forw=!forw;
        }
        return ans;
    }
}

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

3)ADD TWO NUMBERS 

//SOLUTION IN JAVA 

class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode dummy=new ListNode(-1);
        ListNode curr=dummy;
        int carry=0; 
        while(l1!=null || l2!=null || carry==1)
        {
            int sum=0; 
            if(l1!=null)
            { 
                sum+=l1.val;
                l1=l1.next;
            }
            if(l2!=null){
                sum+=l2.val;
                l2=l2.next;
            }
            sum+=carry; 
            carry=sum/10; 
            ListNode node =new ListNode(sum % 10); 
            curr.next=node;
            curr=curr.next; 
        }
        return dummy.next; 
    }
}

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

5)ZIGZAG CONVERSION 

//SOLUTION IN JAVA 

class Solution 
{
    public String convert(String s, int numRows)
    {
        if (numRows==1)
        {
            return s;
        } 
        int n=s.length();
        int parts=(int) Math.ceil(n / (2 * numRows - 2.0));
        int numCols=parts*(numRows-1);
        char[][] matrix=new char[numRows][numCols];
        for(char[] row: matrix)
        {
            Arrays.fill(row,' ');
        }
        int currRow=0; 
        int currCol=0;
        int csi=0;
        while(csi<n) 
        {
            while(currRow<numRows && csi<n)
            {
                matrix[currRow][currCol]=s.charAt(csi);
                currRow++;
                csi++;
            } 
            currRow-=2;
            currCol++;
            while (currRow>0 && currCol<numCols && csi<n)
            {
                matrix[currRow][currCol] = s.charAt(csi);
                currRow--;
                currCol++;
                csi++;
            }
        }     
        StringBuilder res=new StringBuilder();
        for(char[] row: matrix)
        {
            for(char character: row) {
                if(character!=' ') {
                    res.append(character);
                }
            }
        }      
        return res.toString();
    }
}

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

6)BINARY TREE LEVEL ORDER TRAVERSAL ||

//SOLUTION IN JAVA 

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrderBottom(TreeNode root)
    {
        List<List<Integer>>ans=new LinkedList<>();
        if(root==null)
        {
            return ans;
        }
        Queue<TreeNode>n=new LinkedList<>();
        n.add(root);
        while(!n.isEmpty())
        {
            List<Integer>l=new ArrayList<>();
            int count=n.size();
            for(int i=0;i<count;i++)
            {
                TreeNode cur=n.poll();
                l.add(cur.val);
                if(cur.left!=null){
                    n.add(cur.left);
                }
                if(cur.right!=null){
                    n.add(cur.right);
                }
                
            }
            ans.add(l);
        }
        Collections.reverse(ans);
        return ans;
    }
}

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


7)REVERSE INTEGER 

//SOLUTION IN PYTHON 


class Solution:
    def reverse(self, x: int) -> int:
        s=''
        g=str(x)
        if g[0]=="-":
            s+="-"
            g=g[1:]
        if g[0]=="0":
            i=0
            while(i<len(g) and g[i]=="0"):
                g=g[i:]
                i+=1
        s+=g[::-1]
        if(-2**31<=int(s)<=2**31-1):
            return int(s)
        else:
            return 0
            
 --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 
 
8)RANGE SUM OF BST 

//SOLUTION IN JAVA 

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int sum=0;
    public void sum(TreeNode root,int low,int high){
        if(low<=root.val && root.val<=high){
            sum+=root.val;
        }
        if(root.left!=null){
            sum(root.left,low,high);
        }
        if(root.right!=null){
            sum(root.right,low,high);
        }
    }
    public int rangeSumBST(TreeNode root, int low, int high) {
        sum(root,low,high);
        return sum;
    }
}

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

9)INCREASING ORDER SEARCH TREE 

//SOLUTION IN JAVA 

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    List<Integer> list=new ArrayList<>();
    public TreeNode increasingBST(TreeNode root) {
        inorder(root);
        TreeNode res=new TreeNode();
        TreeNode temp=res;
        for(int i=0;i<list.size();i++){
            temp.right=new TreeNode(list.get(i));
            temp=temp.right;
        }
        return res.right;
    }
    public void inorder(TreeNode root){
        if(root==null){
            return ;
        }
        inorder(root.left);
        list.add(root.val);
        inorder(root.right);
    }
}

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

